<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Visualizador de Branches e Commits do GitHub</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    h1 {
      color: #333;
    }
    .container {
      text-align: center;
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    input {
      padding: 10px;
      width: 300px;
      margin-bottom: 20px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    button {
      padding: 10px 15px;
      border: none;
      background-color: #28a745;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #218838;
    }
    table {
      width: 100%;
      margin-top: 20px;
      border-collapse: collapse;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: left;
      vertical-align: top;
    }
    th {
      background-color: #f2f2f2;
    }
    .commits {
      font-size: 0.9em;
      color: #555;
    }
    .second-table {
      margin-top: 30px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Visualizador de Branches e Commits do GitHub</h1>
    <input type="text" id="repoInput" placeholder="Digite o usuário/repositório (ex: facebook/react)" />
    <button onclick="fetchBranches()">Buscar Branches</button>
    <div id="commitTable"></div>
    <div id="secondTable" class="second-table"></div>
  </div>

  <script>
    let lastCommitSha = {}; // Armazena o SHA do último commit por branch

    // Função para buscar branches do repositório
    async function fetchBranches() {
      const repoInput = document.getElementById('repoInput').value;
      const commitTable = document.getElementById('commitTable');
      const secondTable = document.getElementById('secondTable');
      commitTable.innerHTML = ''; // Limpa a tabela
      secondTable.innerHTML = ''; // Limpa a segunda tabela

      if (!repoInput) {
        alert('Por favor, insira um repositório válido');
        return;
      }

      try {
        const response = await fetch(`https://api.github.com/repos/${repoInput}/branches`);
        if (!response.ok) {
          throw new Error('Repositório não encontrado ou API rate limit atingido');
        }

        const branches = await response.json();

        if (branches.length === 0) {
          commitTable.innerHTML = '<p>Não há branches neste repositório.</p>';
          return;
        }

        branches.sort((a, b) => (a.name === "main" ? -1 : b.name === "main" ? 1 : 0));

        // Criar primeira tabela (commits)
        let table = `<table><thead><tr>`;
        branches.forEach(branch => {
          table += `<th>${branch.name}</th>`;
          lastCommitSha[branch.name] = ''; // Inicia o SHA do último commit como vazio
        });
        table += `</tr></thead><tbody><tr>`;

        // Criar uma linha para cada branch
        for (let branch of branches) {
          table += `<td><ul id="commits-${branch.name}" class="commits"><li>Carregando commits...</li></ul></td>`;
          fetchCommits(repoInput, branch.name);
        }
        table += `</tr></tbody></table>`;
        commitTable.innerHTML = table;

        // Criar segunda tabela (status "ok")
        createSecondTable(branches);

        // Verificar novos commits a cada 60 segundos
        setInterval(() => {
          branches.forEach(branch => {
            checkNewCommits(repoInput, branch.name);
          });
        }, 60000); // 60 segundos

      } catch (error) {
        alert('Erro ao buscar branches: ' + error.message);
      }

      // Atualiza a segunda tabela a cada 5 segundos
      setInterval(updateSecondTable, 5000);
    }

    // Função para buscar commits de uma branch
    async function fetchCommits(repo, branch) {
      const commitList = document.getElementById(`commits-${branch}`);
      commitList.innerHTML = ''; // Limpa a lista de commits

      try {
        const response = await fetch(`https://api.github.com/repos/${repo}/commits?sha=${branch}`);
        if (!response.ok) {
          throw new Error('Erro ao buscar commits ou limite da API atingido');
        }

        const commits = await response.json();

        if (commits.length === 0) {
          commitList.innerHTML = '<li>Sem commits neste branch.</li>';
          return;
        }

        lastCommitSha[branch] = commits[0].sha;

        commits.forEach(commit => {
          const li = document.createElement('li');
          li.textContent = `${commit.commit.message} - ${commit.commit.author.name} (${new Date(commit.commit.author.date).toLocaleDateString()})`;
          commitList.appendChild(li); 
        });

      } catch (error) {
        commitList.innerHTML = `<li>Erro ao carregar commits: ${error.message}</li>`;
      }
    }

    // Função para verificar novos commits em um branch
    async function checkNewCommits(repo, branch) {
      const commitList = document.getElementById(`commits-${branch}`);

      try {
        const response = await fetch(`https://api.github.com/repos/${repo}/commits?sha=${branch}`);
        if (!response.ok) {
          throw new Error('Erro ao buscar novos commits ou limite da API atingido');
        }

        const commits = await response.json();

        if (commits.length > 0 && commits[0].sha !== lastCommitSha[branch]) {
          const newCommits = commits.filter(commit => commit.sha !== lastCommitSha[branch]);
          newCommits.reverse().forEach(commit => {
            const li = document.createElement('li');
            li.textContent = `${commit.commit.message} - ${commit.commit.author.name} (${new Date(commit.commit.author.date).toLocaleDateString()})`;
            commitList.prepend(li); 
          });

          lastCommitSha[branch] = commits[0].sha;
        }

      } catch (error) {
        console.error(`Erro ao verificar novos commits no branch ${branch}: ${error.message}`);
      }
    }

    // Função para criar a segunda tabela
    function createSecondTable(branches) {
      let table = `<table><thead><tr>`;
      branches.forEach(branch => {
        table += `<th>${branch.name}</th>`;
      });
      table += `</tr></thead><tbody><tr>`;

      branches.forEach(branch => {
        table += `<td><ul id="status-${branch.name}"><li>Esperando...</li></ul></td>`;
      });

      table += `</tr></tbody></table>`;
      document.getElementById('secondTable').innerHTML = table;
    }

    // Função para atualizar a segunda tabela com "ok" para cada commit
    function updateSecondTable() {
      const commitTable = document.querySelectorAll('.commits');

      commitTable.forEach(commitList => {
        const branch = commitList.id.replace('commits-', '');
        const statusList = document.getElementById(`status-${branch}`);
        statusList.innerHTML = ''; // Limpa a lista de status

        const commitCount = commitList.children.length;
        for (let i = 0; i < commitCount; i++) {
          const li = document.createElement('li');
          li.textContent = "ok";
          statusList.appendChild(li); // Adiciona um "ok" para cada commit
        }
      });
    }
  </script>
</body>
</html>
